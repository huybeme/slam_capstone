#----------- start ------------------#
# this was for robot world
# the purpose was to create an array of arrays from the map
# in order to use numpy to flip the map to align with rviz2
# and then write it into a text file

        # build 2D array from 1D OccupancyGrid -- may not be necessary
        processed_grid = []
        temp_grid = []
        for height, cell in enumerate(msg.data, 1):
            temp_grid.append(cell)
            if height % msg.info.width == 0 and height > 0:
                processed_grid.append(temp_grid)
                temp_grid = []

        # 2D grid allows np to flip the array since OccupancyGrid is mirrored
        # relative to rviz2
        # processed_grid = np.flipud(processed_grid)    # may not be needed

        # get the grid and output into a text file -- mainly used for troubleshooting
        i_tracker = 0
        with open('local_grid.txt', 'w') as output_grid:
            for height, j in enumerate(processed_grid):
                for width, grid in enumerate(processed_grid[height]):
                    i_tracker += 1
                    if grid == -1:
                        output_grid.write("  *  ")
                    elif grid >= 0 and grid < 10:
                        output_grid.write("  " + str(grid) + "  ")
                    elif grid >= 10 and grid < 100:
                        output_grid.write("  " + str(grid) + " ")
                    elif grid == 100:
                        output_grid.write(" " + str(grid) + " ")
                    else:
                        output_grid.write(" ")

                    if i_tracker == robot_i:
                        output_grid.write("  r  ")

                    if i_tracker == si:
                        output_grid.write("  m  ")

                    for i in start_area_i:
                        if i_tracker == i:
                            output_grid.write("  s  ")

                output_grid.write("\n")
        i_tracker = 0

    #for i in range(len(msg.data) -1, -1, -1): enumerate array backwards

#----------- start ------------------#










    ####################################################
    '''might not needed since we will put this in a module instead. will remove if I can figure out how
    to get rid of the publisher reigstered node name warning.'''
    def send_request(self):
        client = self.create_client(SetBool, 'robot_initialization')

        # send request is not asynchronous; node stuck in while loop with no other actions
        while not client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info("waiting for robot world to recieve request")
        req = SetBool.Request()
        req.data = True

        future = client.call_async(req)

        future.add_done_callback(
            # response not used as variable, only for troubleshooting as messages
            partial(self.call_send_service, data=False)
        )
        self.get_logger().info("robot world node recieved request")

    def call_send_service(self, future, data):
        try:
            response = future.result()
            # "true" and "got your message"
            self.get_logger().info(str(response.success))
            self.get_logger().info(str(response.message))
        except:
            self.get_logger().info("service call failed")
    ##########################################################



    import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import time
import signal

from capstone_interfaces.msg import TB3Status
from capstone_interfaces.srv import State

import capstone_pkg.capstone_function as capstone_function


class circle_around_node(Node):
    def __init__(self):
        super().__init__("circle_around")

        self.tb_status = TB3Status()
        self.get_lidar_val = self.create_subscription(
            TB3Status, "tb3_status", self.callback_lidar_and_move, 10)

        self.movement = Twist()
        self.publish_movement = self.create_publisher(
            Twist, "cmd_vel", 10
        )

        self.circle_service_check = self.create_service(
            State, "robot_movement_state", self.callback_movement_state
        )

        self.state = 0

        # if user stopped program with ctrl + C, will initiate this function
        signal.signal(signal.SIGINT, self.user_stop_movement)
        self.get_logger().info("circling around node has begun")

    def callback_movement_state(self, request, response):
        req = request.state
        if type(req) is int:
            self.state = req
            response.success = True
            return response
        else:
            response.success = False
            return response

    def callback_lidar_and_move(self, msg):

        if self.state == 0:
            self.setup_initial_state(msg.lidar_data)

        if self.state == 1:
            # does not print until request is completed - will also be stuck here if no response is recieved
            print(capstone_function.send_service_request(
                self, "robot_world_check", "robot_world"))
            self.state = 2

        if self.state == 2:
            self.move_along_wall(msg.lidar_data)

        # this state will be reached through tb3_map_server node by service requests
        if self.state == -99:
            self.stop_movement()
            self.state = -100
            exit(0)

        self.publish_movement.publish(self.movement)

    def move_along_wall(self, lidar):
        # may get stuck in concave that is just bigger than robot
        self.movement.linear.x = 0.1
        print("moving along wall")

        # hit a wall
        if lidar[1] < 0.38 and lidar[1] > 0.01:
            self.make_turn(1)

        # align to wall
        elif lidar[4] > 0.003 and lidar[4] <= 1.0:
            x = (lidar[2] - 0.4) * 1.5
            x = self.cube_root(x)
            self.movement.angular.z = -x  # -0.357 * lidar[4] + 0.15
            print(1, self.three_decimals(x), lidar[4])

        else:
            self.movement.angular.z = 0.0

    def setup_initial_state(self, lidar):

        if lidar[1] < 0.4 and lidar[1] > 0.01:    # too close to wall
            self.movement.linear.x = -0.05
            if lidar[1] > 0.39:
                self.state = 1
                self.stop_movement()

        elif lidar[1] > 0.39:
            if lidar[1] < 0.4:
                self.state = 1
                self.stop_movement()
            speed = 0.22 - ((-0.229 * lidar[1]) + 0.229)
            if speed > 0.22:
                self.movement.linear.x = 0.21
            else:
                # 0.21 - ((-0.229 * lidar[1]) + 0.229)
                self.movement.linear.x = speed

    def make_turn(self, direction):
        # direction -1 == left  1 == right
        print("turning")
        self.movement.linear.x = 0.0
        self.movement.angular.z = 0.9 * direction
        self.publish_movement.publish(self.movement)
        time.sleep(0.5)
        self.stop_movement()

    def stop_movement(self):
        self.movement.angular.z = 0.0
        self.movement.linear.x = 0.0
        self.publish_movement.publish(self.movement)
        # should I wait a few seconds here?

    def user_stop_movement(self, signal_received, frame):
        self.stop_movement()
        self.state = -99
        self.get_logger().info("user stoped circle around movement")
        exit(0)

    def cube_root(self, x):
        ''' prevent real number output done by python, this helps prevent output of real number
            https://stackoverflow.com/questions/42189413/wrong-value-for-cube-root-in-python'''
        if x >= 0:
            return x ** (1/3)
        else:
            return -(-x) ** (1/3)

    def three_decimals(self, x):
        return '{0:.3g}'.format(x)


def main(args=None):
    rclpy.init(args=args)
    node = circle_around_node()

    rclpy.spin(node)

    rclpy.shutdown()


if __name__ == '__main__':
    main()


#################################